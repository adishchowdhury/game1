<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Racing Game</title>
    <style>
        :root {
            --color-background: #1a1a1a;
            --color-surface: #2a2a2a;
            --color-text: #f5f5f5;
            --color-primary: #32b8c6;
            --color-road: #4a4a4a;
            --color-grass: #2d5016;
            --color-line: #ffffff;
            --color-car: #ff4444;
            --color-opponent: #4444ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--color-background);
            color: var(--color-text);
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #videoContainer {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 280px;
            height: 210px;
            border: 3px solid var(--color-primary);
            border-radius: 12px;
            overflow: hidden;
            z-index: 100;
            background: var(--color-surface);
            box-shadow: 0 4px 12px rgba(50, 184, 198, 0.3);
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            display: block;
        }

            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(50, 184, 198, 0.9);
            color: #1a1a1a;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
        }

            background: rgba(46, 204, 113, 0.9);
        }

        #status {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(42, 42, 42, 0.9);
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid var(--color-primary);
            z-index: 100;
            min-width: 200px;
        }

        #status h3 {
            margin-bottom: 10px;
            color: var(--color-primary);
            font-size: 18px;
        }

        #status p {
            margin: 5px 0;
            font-size: 14px;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #startScreen, #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 26, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        #gameOverScreen {
            display: none;
        }

        .screen-title {
            font-size: 48px;
            font-weight: bold;
            color: var(--color-primary);
            margin-bottom: 20px;
        }

        .instructions {
            text-align: center;
            margin: 20px;
            max-width: 600px;
            line-height: 1.6;
        }

        .instructions p {
            margin: 10px 0;
        }

        .btn {
            background: var(--color-primary);
            color: var(--color-background);
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: scale(1.05);
            background: #29a0ad;
        }

        #finalScore {
            font-size: 32px;
            margin: 20px 0;
        }

            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(42, 42, 42, 0.8);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 14px;
            color: var(--color-text);
            z-index: 100;
            border: 1px solid rgba(50, 184, 198, 0.3);
        }

        .heart {
            color: #ff4444;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="startScreen">
            <h1 class="screen-title">üèéÔ∏è Face Racing Game</h1>
            <div class="instructions">
                <p><strong>How to Play:</strong></p>
                <p>üéØ Tilt your head <strong>LEFT</strong> to steer left</p>
                <p>üéØ Tilt your head <strong>RIGHT</strong> to steer right</p>
                <p>‚úã Show your <strong>PALM</strong> to pause the game</p>
                <p>‚ö†Ô∏è Avoid obstacles and drive as far as you can!</p>
            </div>
            <button class="btn" onclick="startGame()">Start Game</button>
        </div>

        <div id="gameOverScreen">
            <h1 class="screen-title">Game Over!</h1>
            <p id="finalScore"></p>
            <button class="btn" onclick="restartGame()">Play Again</button>
        </div>

        <div id="videoContainer">
            <video id="webcam" autoplay playsinline muted></video>
            <div id="cameraStatus">Initializing...</div>
        </div>

        <div id="status">
            <h3>Status</h3>
            <p>Direction: <span id="direction">Center</span></p>
            <p>Gesture: <span id="gesture">None</span></p>
            <p>Score: <span id="score">0</span></p>
            <p>Speed: <span id="speed">5</span></p>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="credits">
            Created with <span class="heart">‚ù§Ô∏è</span> by Adrija Chowdhury
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('webcam');

        // Game state
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let gameSpeed = 5;
        let carX = 0;
        let targetCarX = 0;
        let obstacles = [];
        let roadOffset = 0;

        // Face and hand detection state
        let headTilt = 0;
        let palmDetected = false;

        // Canvas setup
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Initialize MediaPipe Face Mesh
        const faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.3,
            minTrackingConfidence: 0.3
        });

        faceMesh.onResults(onFaceResults);

        // Initialize MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 0,
            minDetectionConfidence: 0.3,
            minTrackingConfidence: 0.3
        });

        hands.onResults(onHandResults);

        // Face detection callback
        function onFaceResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // Use ear-to-ear angle for better tilt detection
                const leftEar = landmarks[234];
                const rightEar = landmarks[454];
                const nose = landmarks[1];
                
                // Calculate horizontal tilt - INVERTED for natural mirror control
                // When you tilt left, nose moves right in video (mirrored), car should go left
                const earDiff = leftEar.x - rightEar.x;
                const noseTilt = -(nose.x - 0.5) * 4; // Negative to invert direction
                
                headTilt = noseTilt;
                
                // Update UI with more sensitive thresholds
                if (headTilt > 0.2) {
                    document.getElementById('direction').textContent = 'Left ‚¨ÖÔ∏è';
                } else if (headTilt < -0.2) {
                    document.getElementById('direction').textContent = 'Right ‚û°Ô∏è';
                } else {
                    document.getElementById('direction').textContent = 'Center ‚¨ÜÔ∏è';
                }
            } else {
                // Reset if no face detected
                headTilt = headTilt * 0.9; // Slowly center
            }
        }

        // Hand detection callback
        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Simpler palm detection - check if fingers are spread
                const wrist = landmarks[0];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                
                // Check if fingertips are above mid-palm
                const midPalm = landmarks[9];
                const fingerCount = [indexTip, middleTip, ringTip, pinkyTip].filter(
                    tip => tip.y < midPalm.y
                ).length;
                
                palmDetected = fingerCount >= 3;
                
                if (palmDetected && gameRunning && !gamePaused) {
                    gamePaused = true;
                    document.getElementById('gesture').textContent = 'Palm - PAUSED ‚úã';
                } else if (!palmDetected && gamePaused) {
                    gamePaused = false;
                    document.getElementById('gesture').textContent = 'None';
                }
                
                document.getElementById('gesture').textContent = palmDetected ? 'Palm Detected ‚úã' : 'None';
            } else {
                palmDetected = false;
                document.getElementById('gesture').textContent = 'None';
            }
        }

        // Setup camera
        async function setupCamera() {
            const statusEl = document.getElementById('cameraStatus');
            try {
                statusEl.textContent = 'Requesting camera...';
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    } 
                });
                video.srcObject = stream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        statusEl.textContent = 'üü¢ LIVE';
                        statusEl.className = 'active';
                        resolve(video);
                    };
                });
            } catch (err) {
                statusEl.textContent = '‚ùå Camera Error';
                alert('Camera access required to play the game! Please allow camera permissions and reload.');
                console.error('Camera error:', err);
            }
        }

        // Detection loop - runs both detections every frame
        async function detectLoop() {
            if (!video.srcObject) return;
            
            try {
                // Send to both detectors every frame for real-time response
                await faceMesh.send({ image: video });
                await hands.send({ image: video });
            } catch (err) {
                console.error('Detection error:', err);
            }
            
            requestAnimationFrame(detectLoop);
        }

        // Game functions
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            
            // Complete game state reset
            gameRunning = true;
            gamePaused = false;
            score = 0;
            gameSpeed = 5;
            obstacles = [];
            carX = canvas.width / 2;
            targetCarX = carX;
            
            // Reset detection states completely
            headTilt = 0;
            palmDetected = false;
            
            // Reset UI
            document.getElementById('direction').textContent = 'Center ‚¨ÜÔ∏è';
            document.getElementById('gesture').textContent = 'None';
            document.getElementById('score').textContent = '0';
            document.getElementById('speed').textContent = '5';
            
            setupCamera().then(() => {
                detectLoop();
                gameLoop();
            });
        }

        async function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            
            // Full reset of all detection states
            gamePaused = false;
            headTilt = 0;
            palmDetected = false;
            
            // Stop current video stream to force fresh camera initialization
            if (video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                video.srcObject = null;
            }
            
            // Small delay to ensure clean state
            await new Promise(resolve => setTimeout(resolve, 100));
            
            startGame();
        }

        function endGame() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = `Final Score: ${Math.floor(score)}`;
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        // Game rendering
        function drawRoad() {
            const roadWidth = canvas.width * 0.6;
            const roadLeft = (canvas.width - roadWidth) / 2;
            
            // Grass
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Road
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(roadLeft, 0, roadWidth, canvas.height);
            
            // Road lines
            ctx.fillStyle = '#ffffff';
            const lineWidth = 10;
            const lineHeight = 40;
            const lineGap = 30;
            
            roadOffset += gameSpeed;
            if (roadOffset > lineHeight + lineGap) {
                roadOffset = 0;
            }
            
            for (let y = -lineHeight + roadOffset; y < canvas.height; y += lineHeight + lineGap) {
                ctx.fillRect(roadLeft + roadWidth / 2 - lineWidth / 2, y, lineWidth, lineHeight);
            }
        }

        function drawCar() {
            const carWidth = 40;
            const carHeight = 70;
            const carY = canvas.height - 150;
            
            // Update car position based on head tilt with stronger response
            const roadWidth = canvas.width * 0.6;
            const roadLeft = (canvas.width - roadWidth) / 2;
            const roadRight = roadLeft + roadWidth;
            
            targetCarX = canvas.width / 2 + (headTilt * roadWidth * 0.8);
            targetCarX = Math.max(roadLeft + carWidth / 2, Math.min(roadRight - carWidth / 2, targetCarX));
            
            // Faster, more responsive movement
            carX += (targetCarX - carX) * 0.3;
            
            // Draw car body
            ctx.fillStyle = '#ff4444';
            ctx.fillRect(carX - carWidth / 2, carY, carWidth, carHeight);
            
            // Car windows
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(carX - carWidth / 2 + 5, carY + 10, carWidth - 10, 20);
            
            // Wheels
            ctx.fillStyle = '#000000';
            ctx.fillRect(carX - carWidth / 2 - 5, carY + 10, 8, 15);
            ctx.fillRect(carX + carWidth / 2 - 3, carY + 10, 8, 15);
            ctx.fillRect(carX - carWidth / 2 - 5, carY + carHeight - 25, 8, 15);
            ctx.fillRect(carX + carWidth / 2 - 3, carY + carHeight - 25, 8, 15);
        }

        function updateObstacles() {
            const roadWidth = canvas.width * 0.6;
            const roadLeft = (canvas.width - roadWidth) / 2;
            
            // Spawn new obstacles - increase frequency over time
            const spawnDistance = Math.max(100, 200 - Math.floor(score / 50));
            if (obstacles.length === 0 || obstacles[obstacles.length - 1].y > spawnDistance) {
                const lanes = 3;
                const laneWidth = roadWidth / lanes;
                const randomLane = Math.floor(Math.random() * lanes);
                
                obstacles.push({
                    x: roadLeft + randomLane * laneWidth + laneWidth / 2,
                    y: -50,
                    width: 40,
                    height: 70
                });
            }
            
            // Update and draw obstacles
            obstacles = obstacles.filter(obs => {
                obs.y += gameSpeed;
                
                // Draw obstacle
                ctx.fillStyle = '#4444ff';
                ctx.fillRect(obs.x - obs.width / 2, obs.y, obs.width, obs.height);
                
                // Check collision
                const carWidth = 40;
                const carHeight = 70;
                const carY = canvas.height - 150;
                
                if (obs.y + obs.height > carY &&
                    obs.y < carY + carHeight &&
                    Math.abs(obs.x - carX) < (obs.width + carWidth) / 2) {
                    endGame();
                }
                
                return obs.y < canvas.height;
            });
        }

        function gameLoop() {
            if (!gameRunning) return;
            
            if (!gamePaused) {
                // Update game
                score += 0.5;
                gameSpeed = 5; // Keep constant speed
                
                // Draw
                drawRoad();
                updateObstacles();
                drawCar();
                
                // Update UI
                document.getElementById('score').textContent = Math.floor(score);
                document.getElementById('speed').textContent = gameSpeed.toFixed(1);
            } else {
                // Draw paused state
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            }
            
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>

